"""
Command Utility Functions

This module provides utility functions for CLI command implementations.
"""
from typing import List, Dict, Any, Optional, Set, Tuple
import logging
import sys
import os
import json
import re

# Add a mapping for task types to emojis
TASK_TYPE_EMOJI_MAP = {
    "task": "ðŸ“",
    "bug": "ðŸ›",
    "feature": "ðŸš€",
    "refactor": "â™»ï¸",
    "documentation": "ðŸ“š",
    "enhancement": "âœ¨",
    "chore": "ðŸ§¹",
    "research": "ðŸ”¬",
    "testing": "ðŸ§ª",
    "security": "ðŸ›¡ï¸",
    "project": "ðŸ“‚",
    "milestone": "ðŸ"
}

# Add tag emoji
TAG_EMOJI = "ðŸ·ï¸"

def validate_tree_structure(tree_lines: List[str]) -> Tuple[bool, List[str]]:
    """
    Validates the consistency of the tree structure,
    particularly focusing on vertical pipe characters.
    
    Task: tsk_fa92b435 - Tree Structure Validation
    dohcount: 2
    
    Parameters:
        tree_lines: List of rendered tree lines
    
    Returns:
        Tuple of (is_valid, error_messages)
    """
    errors = []
    pipe_positions = {}
    
    # First pass: Find expected pipe positions
    for i, line in enumerate(tree_lines):
        # Skip empty lines
        if not isinstance(line, str) or not line.strip():
            continue
            
        # Skip tag lines from validation requirements
        if TAG_EMOJI in line and line.strip().startswith(TAG_EMOJI):
            continue
            
        # Track indent level and pipe positions
        indent_level = 0
        j = 0
        while j < len(line):
            char = line[j]
            
            if char == 'â”‚':
                if indent_level not in pipe_positions:
                    pipe_positions[indent_level] = set()
                pipe_positions[indent_level].add(j)
                j += 1  # Move past the pipe
            elif char in ('â”œ', 'â””'):
                # This position indicates a branch, which means
                # there should be pipes at this position in other lines
                if indent_level not in pipe_positions:
                    pipe_positions[indent_level] = set()
                pipe_positions[indent_level].add(j)
                
                # Next level's indentation starts after branch character
                indent_level += 1
                j += 2  # Skip the branch character and the dash
            else:
                j += 1  # Move to next character
    
    # Second pass: Verify pipe consistency
    for i, line in enumerate(tree_lines):
        if not isinstance(line, str) or not line.strip():
            continue
            
        # Skip tag lines from validation
        if TAG_EMOJI in line and line.strip().startswith(TAG_EMOJI):
            continue
            
        # Check each level's pipe positions
        for level, positions in sorted(pipe_positions.items()):
            for pos in sorted(positions):
                # Skip if position is beyond this line
                if pos >= len(line):
                    continue
                    
                # If we expect a pipe at this position
                expected_chars = ('â”‚', 'â”œ', 'â””', ' ')
                
                # Check if the character is not a pipe or branch and it should be
                if (line[pos] not in expected_chars and 
                    # Only validate if this line should have a pipe at this position
                    # based on its indentation level and structure
                    _should_have_pipe_at_position(line, pos, level)):
                    errors.append(f"Line {i+1}: Expected vertical pipe or branch at position {pos+1}, found '{line[pos]}'")
    
    return len(errors) == 0, errors

def _should_have_pipe_at_position(line: str, pos: int, level: int) -> bool:
    """
    Determines if a line should have a pipe character at a specific position
    based on the line's structure and indentation level.
    
    Task: tsk_fa92b435 - Tree Structure Validation
    dohcount: 1
    
    Parameters:
        line: The line to check
        pos: The position to check for a pipe
        level: The indentation level
    
    Returns:
        True if the line should have a pipe at the position, False otherwise
    """
    # Skip if position is at the beginning of the line or beyond the end
    if pos <= 0 or pos >= len(line):
        return False
        
    # Count leading spaces to determine this line's level
    leading_spaces = len(line) - len(line.lstrip())
    line_level = leading_spaces // 2  # Assuming 2-space indentation
    
    # Only expect pipes for levels that this line should display
    if level >= line_level:
        return False
    
    # Check if the character is within a properly indented section
    # Pipes should appear at positions 0, 2, 4, etc.
    if pos % 2 != 0:
        return False
    
    # Check surrounding characters
    # Pipes typically have spaces before/after them in tree structures
    has_space_before = pos > 0 and line[pos-1] == ' '
    has_space_after = pos < len(line)-1 and line[pos+1] == ' '
    
    # Special case: line might end with a pipe
    if pos == len(line)-1:
        has_space_after = True
    
    return has_space_before and has_space_after

def format_hierarchical_tree(
    tasks: List[Dict[str, Any]],
    parent_id: Optional[str] = None,
    level: int = 0,
    is_last_child: bool = True,
    branch_map: Optional[Dict[int, bool]] = None,
    validate_pipes: bool = True
) -> str:
    """
    Format tasks as a hierarchical tree with proper indentation and tree-style connectors.
    
    Task: tsk_fa92b435 - Tree Structure Validation
    dohcount: 2
    
    Args:
        tasks: List of all tasks
        parent_id: ID of the parent task to filter on (None for root tasks)
        level: Current indentation level
        is_last_child: Whether this is the last child at its level
        branch_map: Map of levels to boolean indicating if branch continues at that level
        validate_pipes: Whether to validate the consistency of vertical pipes
    
    Returns:
        Formatted string with hierarchical tree representation
    """
    if branch_map is None:
        branch_map = {}
        
    # Create a task lookup map for efficiency
    task_map = {task["id"]: task for task in tasks}
    
    # Filter tasks for the current level
    current_level_tasks = [
        task for task in tasks 
        if task.get("parent_id") == parent_id
    ]
    
    if not current_level_tasks:
        return ""
    
    result = []
    
    # Process each task at the current level
    for i, task in enumerate(current_level_tasks):
        # Determine if this is the last child at this level
        is_last = i == len(current_level_tasks) - 1
        
        # Build the prefix based on the branch map
        prefix = ""
        for l in range(level):
            if l in branch_map and branch_map[l]:
                prefix += "â”‚ "
            else:
                prefix += "  "
        
        # Add the appropriate connector for this task
        if is_last:
            connector = "â””â”€"
        else:
            connector = "â”œâ”€"
        
        # Format the task details
        task_details = f"{task.get('name', 'Unnamed Task')}"
        
        # Add status if available
        if status := task.get("status"):
            task_details += f" [{status}]"
        
        # Add task ID if available
        if task_id := task.get("id"):
            task_details += f" ({task_id})"
        
        # Add priority if available
        if priority := task.get("priority"):
            task_details += f" P{priority}"
        
        # Add the formatted task line to the result
        result.append(f"{prefix}{connector}{task_details}")
        
        # Format tags on their own line if available
        if tags := task.get("tags", []):
            # Add tag emoji and format tags in brackets
            tag_text = f"{', '.join(tags)}"
            tag_text_with_emoji = f"{TAG_EMOJI} [{tag_text}]"
            
            # Indentation for tag line - aligned with vertical pipe if not last
            # Important: Use exactly the same prefix logic but extend it by one level
            # This ensures proper alignment with the task's children
            tag_prefix = prefix + ("  " if is_last else "â”‚ ")
            result.append(f"{tag_prefix}{tag_text_with_emoji}")
        
        # Update branch map for child tasks
        new_branch_map = branch_map.copy()
        new_branch_map[level] = not is_last
        
        # Recursively format child tasks
        child_result = format_hierarchical_tree(
            tasks=tasks,
            parent_id=task.get("id"),
            level=level + 1,
            is_last_child=is_last,
            branch_map=new_branch_map,
            validate_pipes=False  # Only validate at top level
        )
        
        if child_result:
            result.append(child_result)
    
    # Join lines with newlines
    joined_result = "\n".join(result)
    
    # Validate tree structure at the root level
    if validate_pipes and level == 0:
        valid, errors = validate_tree_structure(result)
        if not valid:
            logging.warning("Tree structure validation failed:")
            for error in errors:
                logging.warning(error)
            
            # Apply auto-correction
            result = fix_tree_structure(result)
            joined_result = "\n".join(result)
    
    return joined_result

def format_task_hierarchy(
    tasks: List[Dict[str, Any]],
    indent: int = 2,
    colorize_output: bool = False,
    show_details: bool = False,
    show_full: bool = False,
    organize_by_container: bool = False,
    dependency_as_tree: bool = False,
    dependency_type: str = None,
    include_completed: bool = False,
    hide_orphaned: bool = False,
    show_score: bool = False,
    show_tags: bool = False,
    tag_style: str = "colored",
    show_type_emoji: bool = True,
    validate_pipes: bool = True
) -> str:
    """
    Format tasks as a hierarchical tree.
    
    Task: tsk_309ea4c2 - Improve Container Hierarchy Display
    dohcount: 9
    
    Related Tasks:
        - tsk_ef072a47 - Display Features (parent)
        - stk_b4c3d9a2 - Fix Orphaned Task Detection (subtask)
        - stk_d1e8f4a3 - Add Container Path Display (subtask)
        - tsk_22a152df - Show Tags Option (related)
        - tsk_da3dfe13 - Descriptive Task Display (related)
        - tsk_fa92b435 - Tree Structure Validation (related)
    
    Used By:
        - ListTasksCommand: To display tasks in a hierarchical format
    
    Purpose:
        Formats a list of tasks as a hierarchical tree based on parent-child relationships
        or container organization.
    
    Requirements:
        - Must handle different organization modes (parent-child, container)
        - Must properly indent and format the tree structure
        - Must support filtering completed tasks
        - CRITICAL: Must maintain consistent visual connections between related items
        - CRITICAL: Must validate pipe alignment when requested
    
    Parameters:
        tasks: List of task dictionaries
        indent: Number of spaces per indentation level
        colorize_output: Whether to use ANSI colors in output
        show_details: Whether to show detailed task information
        show_full: Whether to show full task details
        organize_by_container: Whether to organize by container hierarchy
        dependency_as_tree: Whether to organize by dependencies
        dependency_type: Type of dependency to use (blocks, depends_on)
        include_completed: Whether to include completed tasks
        hide_orphaned: Whether to hide orphaned tasks
        show_score: Whether to show task scores
        show_tags: Whether to show task tags
        tag_style: Style for tag display
        show_type_emoji: Whether to show task type emoji
        validate_pipes: Whether to validate the tree structure
        
    Returns:
        Formatted string with task hierarchy
    """
    # Early exit if no tasks
    if not tasks:
        return "No tasks found."
        
    # Build a mapping of task IDs to tasks
    tasks_map = {task.get('id'): task for task in tasks if 'id' in task}
    
    # Set to track displayed tasks to avoid duplicates
    displayed_tasks = set()
    
    # Set to track orphaned tasks and their subtasks
    orphaned_task_ids = set()
    
    # List to hold the formatted output lines
    lines = []
    
    # Handle container-based organization
    if organize_by_container:
        return _format_container_hierarchy(
            tasks,
            indent=indent,
            colorize_output=colorize_output,
            show_details=show_details,
            show_full=show_full,
            include_completed=include_completed,
            hide_orphaned=hide_orphaned,
            show_score=show_score,
            show_tags=show_tags,
            tag_style=tag_style,
            show_type_emoji=show_type_emoji,
            validate_pipes=validate_pipes
        )
    
    # Handle dependency-based organization
    elif dependency_as_tree and dependency_type:
        # TODO: Implement dependency-based tree
        return "Dependency tree not yet implemented"
    
    # Handle regular parent-child hierarchy
    else:
        def collect_orphaned_subtasks(task_id):
            # Find direct subtasks
            subtask_ids = set()
            direct_subtasks = [t for t in tasks if t.get('parent_id') == task_id]
            
            for subtask in direct_subtasks:
                subtask_id = subtask.get('id')
                if subtask_id:
                    subtask_ids.add(subtask_id)
                    # Also collect subtasks of this subtask
                    subtask_ids.update(collect_orphaned_subtasks(subtask_id))
            
            return subtask_ids
            
        # First we need to identify orphaned tasks that are not in container structure
        # but still have parent-child relationships
        for task in tasks:
            task_id = task.get('id')
            parent_id = task.get('parent_id')
            
            # Skip tasks without ID or with undefined parent
            if not task_id or parent_id is None:
                continue
                
            # If parent does not exist in our task map, record as orphaned
            if parent_id not in tasks_map:
                orphaned_task_ids.add(task_id)
                # Also add all subtasks recursively
                orphaned_task_ids.update(collect_orphaned_subtasks(task_id))
        
        # List of top-level tasks (those without parent or with non-existent parent)
        root_tasks = []
        for task in tasks:
            task_id = task.get('id')
            parent_id = task.get('parent_id')
            
            # Skip if already identified as orphaned
            if task_id in orphaned_task_ids:
                continue
                
            # Consider as root if no parent or parent doesn't exist in tasks
            if parent_id is None or parent_id not in tasks_map:
                root_tasks.append(task)
        
        # Sort root tasks by priority
        root_tasks.sort(key=lambda t: (
            t.get('status') == 'complete',  # Completed tasks at end
            int(t.get('priority', 3))       # Higher priority (lower number) first
        ))
        
        # Format each root task with its subtasks
        for i, task in enumerate(root_tasks):
            is_last = i == len(root_tasks) - 1
            
            # Skip completed tasks unless include_completed is True
            if task.get('status') == 'complete' and not include_completed:
                continue
                
            # Format the hierarchical task
            branch_map = {0: not is_last}
            _format_hierarchical_task(
                task,
                tasks_map,
                level=0,
                indent=indent,
                colorize_output=colorize_output,
                show_relationships=False,
                core_manager=None,
                show_content_preview=False,
                content_preview_length=0,
                show_comments=0,
                is_last_at_level=is_last,
                displayed_tasks=displayed_tasks,
                branch_map=branch_map,
                include_completed=include_completed,
                show_score=show_score,
                show_tags=show_tags,
                tag_style=tag_style,
                show_type_emoji=show_type_emoji
            )
            
            # Now add orphaned tasks if not hidden
            if not hide_orphaned and orphaned_task_ids and i == len(root_tasks) - 1:
                orphaned_tasks = [t for t in tasks if t.get('id') in orphaned_task_ids]
                if orphaned_tasks:
                    lines.append("\nNO CONTAINER TASKS:")
                    
                    # Group orphaned tasks by parent
                    orphan_parents = {}
                    for ot in orphaned_tasks:
                        parent_id = ot.get('parent_id')
                        if parent_id not in orphan_parents:
                            orphan_parents[parent_id] = []
                        orphan_parents[parent_id].append(ot)
                    
                    # Format each orphaned group
                    for p_idx, (parent_id, o_tasks) in enumerate(orphan_parents.items()):
                        is_last_group = p_idx == len(orphan_parents) - 1
                        
                        # Sort orphaned tasks by priority
                        o_tasks.sort(key=lambda t: (
                            t.get('status') == 'complete',
                            int(t.get('priority', 3))
                        ))
                        
                        # Format each orphaned task
                        for o_idx, o_task in enumerate(o_tasks):
                            is_last_task = o_idx == len(o_tasks) - 1
                            
                            # Skip completed tasks unless include_completed is True
                            if o_task.get('status') == 'complete' and not include_completed:
                                continue
                                
                            # Get parent name if available
                            parent_name = "Unknown Parent"
                            if parent_id and parent_id not in tasks_map:
                                parent_name = f"Missing Parent ({parent_id})"
                            
                            # Format the task with its subtasks
                            branch_map = {0: not is_last_group or not is_last_task}
                            _format_hierarchical_task(
                                o_task,
                                tasks_map,
                                level=0,
                                indent=indent,
                                colorize_output=colorize_output,
                                show_relationships=False,
                                core_manager=None,
                                show_content_preview=False,
                                content_preview_length=0,
                                show_comments=0,
                                is_last_at_level=is_last_task,
                                displayed_tasks=displayed_tasks,
                                branch_map=branch_map,
                                include_completed=include_completed,
                                show_score=show_score,
                                show_tags=show_tags,
                                tag_style=tag_style,
                                show_type_emoji=show_type_emoji
                            )
    
    # Validate tree structure
    if validate_pipes:
        valid, errors = validate_tree_structure(lines)
        if not valid:
            logging.warning("Tree structure validation failed:")
            for error in errors:
                logging.warning(error)
    
    return "\n".join(lines)

def _format_container_hierarchy(
    tasks: List[Dict[str, Any]],
    indent: int = 2,
    colorize_output: bool = True,
    show_details: bool = False,
    show_full: bool = False,
    include_completed: bool = False,
    hide_orphaned: bool = False,
    show_score: bool = False,
    show_tags: bool = False,
    tag_style: str = "colored",
    show_type_emoji: bool = True,
    validate_pipes: bool = True
) -> str:
    """
    Format tasks in a container hierarchy (spaces -> folders -> lists -> tasks).
    
    Task: tsk_fa92b435 - Tree Structure Validation
    dohcount: 3
    
    Args:
        tasks: List of task dictionaries
        indent: Number of spaces per indentation level
        colorize_output: Whether to use ANSI colors in output
        show_details: Whether to show detailed task information
        show_full: Whether to show full task details
        include_completed: Whether to include completed tasks
        hide_orphaned: Whether to hide orphaned tasks
        show_score: Whether to show task scores
        show_tags: Whether to show tags
        tag_style: Style for tag display
        show_type_emoji: Whether to show task type emoji
        validate_pipes: Whether to validate the tree structure
    
    Returns:
        Formatted string with container hierarchy
    """
    # Import color utilities if needed
    if colorize_output:
        from refactor.utils.colors import TextColor, colorize, completion_stats_color, container_color
    
    # Build a mapping of task IDs to tasks
    tasks_map = {task.get('id'): task for task in tasks if 'id' in task}
    
    # Set to track tasks that should be excluded from counts if hiding orphaned
    orphaned_task_ids = set()
    
    # Track tasks that are subtasks of other tasks - we'll exclude these from container displays
    subtask_ids = set()
    for task in tasks:
        parent_id = task.get('parent_id')
        if parent_id and parent_id in tasks_map:
            subtask_ids.add(task.get('id'))
    
    # Identify tasks with no container assignment
    top_level_orphaned_tasks = []
    for task in tasks:
        # Check for direct container fields
        space_id = task.get('space_id', '')
        folder_id = task.get('folder_id', '')
        list_id = task.get('list_id', '')
        # Also check for container_id field which is set by assign command
        container_id = task.get('container_id', '')
        
        if not space_id and not folder_id and not list_id and not container_id:
            top_level_orphaned_tasks.append(task)
    
    # Get container information from task data
    containers = {
        'spaces': {},
        'folders': {},
        'lists': {}
    }
    
    # Track container hierarchy
    container_hierarchy = {
        'space_to_folders': {},  # space_id -> [folder_ids]
        'folder_to_lists': {},   # folder_id -> [list_ids]
        'list_to_tasks': {}      # list_id -> [task_ids]
    }
    
    # Pre-identify orphaned tasks and their subtasks recursively
    if hide_orphaned:
        # First, build parent-child relationships
        child_to_parent = {}
        for task in tasks:
            parent_id = task.get('parent_id')
            if parent_id:
                child_to_parent[task.get('id')] = parent_id
        
        # Identify root orphans (tasks with non-existent parents)
        root_orphans = set()
        for task in tasks:
            parent_id = task.get('parent_id')
            if parent_id and parent_id not in tasks_map:
                root_orphans.add(task.get('id'))
        
        # Function to recursively collect all subtasks of orphaned tasks
        def collect_orphaned_subtasks(task_id):
            orphaned_task_ids.add(task_id)
            for potential_subtask in tasks:
                if potential_subtask.get('parent_id') == task_id:
                    collect_orphaned_subtasks(potential_subtask.get('id'))
        
        # Collect all orphaned tasks and their subtasks
        for orphan_id in root_orphans:
            collect_orphaned_subtasks(orphan_id)
    
    # First pass: collect container info
    for task in tasks:
        # Skip orphaned tasks when counting if hide_orphaned is True
        if hide_orphaned and task.get('id') in orphaned_task_ids:
            continue
        
        # Extract container info
        space_id = task.get('space_id', '')
        folder_id = task.get('folder_id', '')
        list_id = task.get('list_id', '')
        container_id = task.get('container_id', '')
        
        # If container_id is set but specific container fields aren't, try to determine container type
        if container_id and not (space_id or folder_id or list_id):
            # Check if container_id matches a list
            for lst in containers.get('lists', {}).values():
                if lst.get('id') == container_id:
                    list_id = container_id
                    break
            
            # If not a list, check if it's a folder
            if not list_id:
                for folder in containers.get('folders', {}).values():
                    if folder.get('id') == container_id:
                        folder_id = container_id
                        break
            
            # If not a folder, check if it's a space
            if not folder_id and not list_id:
                for space in containers.get('spaces', {}).values():
                    if space.get('id') == container_id:
                        space_id = container_id
                        break
        
        # Skip if no container info is found
        if not space_id and not folder_id and not list_id and not container_id:
            continue
            
        # Add space if new
        if space_id and space_id not in containers['spaces']:
            containers['spaces'][space_id] = {
                'id': space_id,
                'name': task.get('space_name', f"Space {space_id}"),
                'task_count': 0,
                'completed_count': 0
            }
            
        # Add folder if new
        if folder_id and folder_id not in containers['folders']:
            containers['folders'][folder_id] = {
                'id': folder_id,
                'name': task.get('folder_name', f"Folder {folder_id}"),
                'space_id': space_id,
                'task_count': 0,
                'completed_count': 0
            }
            
            # Update space-to-folders mapping
            if space_id:
                if space_id not in container_hierarchy['space_to_folders']:
                    container_hierarchy['space_to_folders'][space_id] = []
                if folder_id not in container_hierarchy['space_to_folders'][space_id]:
                    container_hierarchy['space_to_folders'][space_id].append(folder_id)
            
        # Add list if new - check for duplicates based on list name within the same folder
        if list_id and list_id not in containers['lists']:
            list_name = task.get('list_name', f"List {list_id}")
            
            # Check if we already have a list with the same name in the same folder
            duplicate_list_id = None
            for existing_id, existing_list in containers['lists'].items():
                if (existing_list['folder_id'] == folder_id and 
                    existing_list['name'] == list_name):
                    duplicate_list_id = existing_id
                    break
            
            # If we found a duplicate, use that list_id instead of creating a new one
            if duplicate_list_id:
                list_id = duplicate_list_id
            else:
                # Add new list
                containers['lists'][list_id] = {
                    'id': list_id,
                    'name': list_name,
                    'folder_id': folder_id,
                    'space_id': space_id,
                    'task_count': 0,
                    'completed_count': 0
                }
                
                # Update folder-to-lists mapping
                if folder_id:
                    if folder_id not in container_hierarchy['folder_to_lists']:
                        container_hierarchy['folder_to_lists'][folder_id] = []
                    if list_id not in container_hierarchy['folder_to_lists'][folder_id]:
                        container_hierarchy['folder_to_lists'][folder_id].append(list_id)
        
        # Update list-to-tasks mapping - include all tasks including subtasks
        if list_id:
            if list_id not in container_hierarchy['list_to_tasks']:
                container_hierarchy['list_to_tasks'][list_id] = []
            if task['id'] not in container_hierarchy['list_to_tasks'][list_id]:
                container_hierarchy['list_to_tasks'][list_id].append(task['id'])
            
        # Update container counts - only if not filtered by include_completed
        is_completed = task.get('status', '').lower() == 'complete'
        should_count = include_completed or not is_completed
        
        if should_count:
            if space_id:
                containers['spaces'][space_id]['task_count'] += 1
                if is_completed:
                    containers['spaces'][space_id]['completed_count'] += 1
                    
            if folder_id:
                containers['folders'][folder_id]['task_count'] += 1
                if is_completed:
                    containers['folders'][folder_id]['completed_count'] += 1
                    
            if list_id:
                containers['lists'][list_id]['task_count'] += 1
                if is_completed:
                    containers['lists'][list_id]['completed_count'] += 1
    
    # Second pass: recalculate container counts from child containers
    # Ensure lists have the correct counts
    for list_id, list_item in containers['lists'].items():
        tasks_in_list = container_hierarchy['list_to_tasks'].get(list_id, [])
        # Get all tasks (including subtasks) - remove the subtask_ids filter
        list_tasks = [t for t in tasks_in_list if 
                    (not hide_orphaned or t not in orphaned_task_ids)]
        
        # Count completed tasks, including subtasks
        completed_count = sum(1 for t in list_tasks if t in tasks_map and 
                            tasks_map[t].get('status', '').lower() == 'complete')
        
        # Update counts - include all tasks, not just top-level ones
        list_item['task_count'] = len(list_tasks)
        list_item['completed_count'] = completed_count
    
    # Recalculate folder counts to include all tasks in their lists
    for folder_id, folder in containers['folders'].items():
        folder_lists = container_hierarchy['folder_to_lists'].get(folder_id, [])
        folder['task_count'] = sum(containers['lists'][l]['task_count'] for l in folder_lists if l in containers['lists'])
        folder['completed_count'] = sum(containers['lists'][l]['completed_count'] for l in folder_lists if l in containers['lists'])
    
    # Recalculate space counts to include all tasks in their folders
    for space_id, space in containers['spaces'].items():
        space_folders = container_hierarchy['space_to_folders'].get(space_id, [])
        space['task_count'] = sum(containers['folders'][f]['task_count'] for f in space_folders if f in containers['folders'])
        space['completed_count'] = sum(containers['folders'][f]['completed_count'] for f in space_folders if f in containers['folders'])
    
    # List to hold the formatted output lines
    result_lines = []
    
    # Helper function to format container with stats
    def format_container(name, container_type, task_count, completed_count, id_str=""):
        stats = f"({completed_count}/{task_count})"
        
        if colorize_output:
            color = container_color(container_type)
            stats_color = completion_stats_color(completed_count, task_count)
            return f"{colorize(name, color)} {colorize(stats, stats_color)}{' ' + colorize(id_str, TextColor.BRIGHT_BLACK) if id_str and show_full else ''}"
        else:
            return f"{name} {stats}{' ' + id_str if id_str and show_full else ''}"
    
    # Add a header line
    if colorize_output:
        result_lines.append(colorize("Tasks organized by container:", TextColor.BRIGHT_WHITE))
    else:
        result_lines.append("Tasks organized by container:")
    
    result_lines.append("")  # Empty line for better readability
    
    # Generate container hierarchy display
    for space_idx, (space_id, space) in enumerate(containers['spaces'].items()):
        # Skip if no tasks or filter out completed
        if space['task_count'] == 0 or (not include_completed and space['completed_count'] == space['task_count']):
            continue
            
        # Track if this is the last space
        is_last_space = space_idx == len(containers['spaces']) - 1
            
        # Format space line with proper branch character
        space_line = format_container(
            space['name'], 
            'space', 
            space['task_count'], 
            space['completed_count'],
            space_id
        )
        
        # Add branch character for top-level items
        if is_last_space and (hide_orphaned or not top_level_orphaned_tasks):
            # Last item in the display
            result_lines.append(f"â””â”€{space_line}")
        else:
            # Not the last item (either another space follows or we'll have orphaned tasks)
            result_lines.append(f"â”œâ”€{space_line}")
        
        # Get folders in this space
        space_folders = container_hierarchy['space_to_folders'].get(space_id, [])
        
        # Process each folder
        for folder_idx, folder_id in enumerate(space_folders):
            folder = containers['folders'].get(folder_id)
            if not folder:
                continue
                
            # Skip if no tasks or filter out completed
            if folder['task_count'] == 0 or (not include_completed and folder['completed_count'] == folder['task_count']):
                continue
                
            # Format folder line with proper branch character
            is_last_folder = folder_idx == len(space_folders) - 1
            
            # Create proper folder prefix with pipes
            if is_last_space and (hide_orphaned or not top_level_orphaned_tasks):
                folder_prefix = "  "  # Space is last, no pipe needed
            else:
                folder_prefix = "â”‚ "  # Space continues, pipe needed
                
            branch = "â””â”€" if is_last_folder else "â”œâ”€"
            
            folder_line = format_container(
                folder['name'], 
                'folder', 
                folder['task_count'], 
                folder['completed_count'],
                folder_id
            )
            result_lines.append(f"{folder_prefix}{branch}{folder_line}")
            
            # Get lists in this folder - ensure unique list IDs
            folder_lists = list(set(container_hierarchy['folder_to_lists'].get(folder_id, [])))
            
            # Process each list - use set to avoid duplicates
            for list_idx, list_id in enumerate(sorted(folder_lists)):
                list_item = containers['lists'].get(list_id)
                if not list_item:
                    continue
                    
                # Skip if no tasks or filter out completed
                if list_item['task_count'] == 0 or (not include_completed and list_item['completed_count'] == list_item['task_count']):
                    continue
                
                # Format list line with proper branch character
                is_last_list = list_idx == len(folder_lists) - 1
                
                # The list prefix needs to account for both space and folder's branch status
                list_prefix = ""
                if is_last_space and (hide_orphaned or not top_level_orphaned_tasks):
                    list_prefix += "  "  # Space is last, no pipe
                else:
                    list_prefix += "â”‚ "  # Space continues, need pipe
                    
                if is_last_folder:
                    list_prefix += "  "  # Folder is last, no pipe
                else:
                    list_prefix += "â”‚ "  # Folder continues, need pipe
                
                branch = "â””â”€" if is_last_list else "â”œâ”€"
                
                list_line = format_container(
                    list_item['name'], 
                    'list', 
                    list_item['task_count'], 
                    list_item['completed_count'],
                    list_id
                )
                result_lines.append(f"{list_prefix}{branch}{list_line}")
                
                # Get tasks in this list - ensure unique task IDs
                list_tasks = list(set(container_hierarchy['list_to_tasks'].get(list_id, [])))
                
                # Collect and sort tasks
                tasks_in_list = []
                for task_id in list_tasks:
                    # Skip orphaned tasks if hide_orphaned is True
                    if hide_orphaned and task_id in orphaned_task_ids:
                        continue
                    if task_id in tasks_map:
                        tasks_in_list.append(tasks_map[task_id])
                
                # Skip lists with no displayable tasks
                if not tasks_in_list:
                    continue
                
                # Calculate task prefix based on container branch status
                task_prefix = ""
                if is_last_space and (hide_orphaned or not top_level_orphaned_tasks):
                    task_prefix += "  "  # Space is last, no pipe
                else:
                    task_prefix += "â”‚ "  # Space continues, need pipe
                    
                if is_last_folder:
                    task_prefix += "  "  # Folder is last, no pipe
                else:
                    task_prefix += "â”‚ "  # Folder continues, need pipe
                    
                if is_last_list:
                    task_prefix += "  "  # List is last, no pipe
                else:
                    task_prefix += "â”‚ "  # List continues, need pipe
                
                # Track which tasks have been displayed
                displayed_task_ids = set()
                
                # Format and add tasks using the helper function
                _format_container_tasks(
                    tasks_in_list,
                    tasks_map,
                    displayed_task_ids,
                    task_prefix,
                    orphaned_task_ids,
                    is_last_space,
                    is_last_folder,
                    is_last_list,
                    result_lines,
                    colorize_output,
                    show_full,
                    include_completed,
                    hide_orphaned,
                    show_score,
                    show_tags,
                    tag_style,
                    show_type_emoji,
                    top_level_orphaned_tasks
                )
    
    # Add top-level orphaned tasks section (tasks with no container)
    if top_level_orphaned_tasks and not hide_orphaned:
        # Add a separator line if we have container tasks
        if containers['spaces']:
            result_lines.append("")
        
        # Format the orphaned tasks header
        if colorize_output:
            from refactor.utils.colors import TextColor, TextStyle
            orphaned_header = colorize("NO CONTAINER TASKS", TextColor.BRIGHT_YELLOW, style=TextStyle.BOLD)
        else:
            orphaned_header = "NO CONTAINER TASKS"
        
        result_lines.append(f"â””â”€{orphaned_header}")
        
        # Filter and sort orphaned tasks
        sorted_orphans = []
        for task in top_level_orphaned_tasks:
            # Skip completed tasks if not including them
            if not include_completed and task.get('status', '').lower() == 'complete':
                continue
            # Skip top-level tasks that are subtasks of other tasks
            parent_id = task.get('parent_id')
            if parent_id and parent_id in tasks_map:
                continue
            # Add to sorted list
            sorted_orphans.append(task)
        
        # Sort by status, priority, name
        sorted_orphans = sorted(
            sorted_orphans,
            key=lambda t: (
                t.get('status', '').lower() == 'complete',  # Incomplete first
                int(t.get('priority', 4)),                 # Lower priority first
                t.get('name', '')                          # Alphabetical
            )
        )
        
        # Set to track displayed tasks
        top_orphan_displayed = set()
        
        # Format each top-level orphaned task
        for i, orphan in enumerate(sorted_orphans):
            is_last = i == len(sorted_orphans) - 1
            
            # Format task info
            task_description = _format_task_basic_info(orphan, colorize_output, show_full, show_score, show_tags, tag_style, show_type_emoji)
            branch_prefix = "   "  # Indentation under the orphaned header
            branch = "â””â”€" if is_last else "â”œâ”€"
            result_lines.append(f"{branch_prefix}{branch}{task_description}")
            
            # Mark as displayed
            top_orphan_displayed.add(orphan.get('id'))
            
            # Get subtasks
            subtasks = _get_subtasks(orphan, tasks_map, include_completed)
            
            # Format subtasks
            if subtasks:
                # Calculate the subtask prefix
                subtask_prefix = branch_prefix + ("  " if is_last else "â”‚ ")
                
                # Format each subtask
                for j, subtask in enumerate(subtasks):
                    # Skip if already displayed
                    if subtask.get('id') in top_orphan_displayed:
                        continue
                    
                    is_last_subtask = j == len(subtasks) - 1
                    subtask_lines = []
                    
                    # Format and add subtask
                    _format_subtask_hierarchy(
                        subtask,
                        tasks_map,
                        subtask_lines,
                        top_orphan_displayed,
                        subtask_prefix,
                        colorize_output,
                        show_full,
                        include_completed,
                        hide_orphaned,
                        orphaned_task_ids,
                        show_score,
                        show_tags,
                        tag_style,
                        show_type_emoji
                    )
                    
                    # Add formatted subtask lines
                    for line in subtask_lines:
                        result_lines.append(line)
    
    # Add a summary line with total task count
    result_lines.append("")
    
    # Count tasks excluding orphaned tasks if hide_orphaned is True, but include subtasks
    if hide_orphaned:
        total_tasks = sum(1 for task in tasks if task.get('id') not in orphaned_task_ids)
        completed_tasks = sum(1 for task in tasks if task.get('status', '').lower() == 'complete' 
                             and task.get('id') not in orphaned_task_ids)
    else:
        total_tasks = len(tasks)
        completed_tasks = sum(1 for task in tasks if task.get('status', '').lower() == 'complete')
    
    # If we're not including completed tasks, don't count them in the total either
    if not include_completed:
        total_tasks = sum(1 for task in tasks if task.get('status', '').lower() != 'complete' 
                         and (not hide_orphaned or task.get('id') not in orphaned_task_ids))
        completed_tasks = 0
    
    if colorize_output:
        completion_color = completion_stats_color(completed_tasks, total_tasks)
        summary = f"Total: {colorize(f'{completed_tasks}/{total_tasks} tasks complete', completion_color)}"
    else:
        summary = f"Total: {completed_tasks}/{total_tasks} tasks complete"
        
    result_lines.append(summary)
    
    # Validate tree structure
    if validate_pipes:
        valid, errors = validate_tree_structure(result_lines)
        if not valid:
            logging.warning("Tree structure validation failed:")
            for error in errors:
                logging.warning(error)
            
            # Apply auto-correction
            result_lines = fix_tree_structure(result_lines)
    
    return "\n".join(result_lines)

def _format_container_tasks(
    tasks_in_list: List[Dict[str, Any]],
    tasks_map: Dict[str, Dict],
    displayed_task_ids: Set[str],
    task_prefix: str,
    orphaned_task_ids: Set[str],
    is_last_space: bool,
    is_last_folder: bool,
    is_last_list: bool,
    result_lines: List[str],
    colorize_output: bool = True,
    show_full: bool = False,
    include_completed: bool = False,
    hide_orphaned: bool = False,
    show_score: bool = False,
    show_tags: bool = False,
    tag_style: str = "colored",
    show_type_emoji: bool = True,
    top_level_orphaned_tasks: List[Dict[str, Any]] = None
) -> None:
    """
    Format tasks within a container (list) and add them to the result lines.
    
    Task: tsk_1e88842d - Tree Structure Validation
    dohcount: 1
    
    Args:
        tasks_in_list: Tasks in the current list
        tasks_map: Map of task IDs to tasks
        displayed_task_ids: Set of task IDs that have already been displayed
        task_prefix: Prefix for the task lines based on container hierarchy
        orphaned_task_ids: Set of task IDs that are orphaned
        is_last_space: Whether this is in the last space
        is_last_folder: Whether this is in the last folder
        is_last_list: Whether this is the last list
        result_lines: List of strings to append formatted output to
        colorize_output: Whether to colorize the output
        show_full: Whether to show full task details
        include_completed: Whether to include completed tasks
        hide_orphaned: Whether to hide orphaned tasks
        show_score: Whether to show scores
        show_tags: Whether to show tags
        tag_style: Style for tags (colored, plain, symbols)
        show_type_emoji: Whether to show task type emoji
        top_level_orphaned_tasks: List of top-level orphaned tasks
    """
    if top_level_orphaned_tasks is None:
        top_level_orphaned_tasks = []
        
    # Get the list tasks (only parent/root tasks within this list)
    list_tasks = []
    for task_id in set([t.get('id') for t in tasks_in_list]):
        # Skip orphaned tasks if hide_orphaned is True
        if hide_orphaned and task_id in orphaned_task_ids:
            continue
            
        if task_id in tasks_map:
            task = tasks_map[task_id]
            list_tasks.append(task)
    
    # Gather root tasks (no parent or parent not in our tasks)
    root_tasks = []
    for task in tasks_in_list:
        parent_id = task.get('parent_id')
        # Add to root tasks only if:
        # 1. Not a subtask of any task in our task map, OR
        # 2. Parent task is not in this list
        if not parent_id or parent_id not in tasks_map or parent_id not in [t.get('id') for t in tasks_in_list]:
            root_tasks.append(task)
    
    # Sort root tasks
    sorted_root_tasks = sorted(
        root_tasks,
        key=lambda t: (
            t.get('status', '').lower() == 'complete',  # Incomplete first
            int(t.get('priority', 4)),                  # Lower priority first
            t.get('name', '')                           # Alphabetical
        )
    )
    
    # Format tasks under this list with proper visual hierarchy
    for root_idx, root_task in enumerate(sorted_root_tasks):
        is_last_root = root_idx == len(sorted_root_tasks) - 1
        
        # Skip if already displayed
        if root_task.get('id') in displayed_task_ids:
            continue
        
        # Format task with proper indentation
        task_lines = []
        
        # Format basic task info
        task_description = _format_task_basic_info(root_task, colorize_output, show_full, show_score, show_tags, tag_style, show_type_emoji)
        branch = "â””â”€" if is_last_root else "â”œâ”€"
        first_task_line = f"{task_prefix}{branch}{task_description}"
        task_lines.append(first_task_line)
        
        # Mark task as displayed
        displayed_task_ids.add(root_task.get('id'))
        
        # Recursively display all subtasks
        _format_subtask_hierarchy(
            root_task,
            tasks_map,
            task_lines,
            displayed_task_ids,
            task_prefix + ("  " if is_last_root else "â”‚ "),
            colorize_output,
            show_full,
            include_completed,
            hide_orphaned,
            orphaned_task_ids,
            show_score,
            show_tags,
            tag_style,
            show_type_emoji
        )
        
        # Add task lines to result lines
        for line in task_lines:
            result_lines.append(line)
    
    # Handle orphaned tasks in this list
    _format_orphaned_list_tasks(
        tasks_in_list, 
        tasks_map, 
        displayed_task_ids, 
        orphaned_task_ids, 
        is_last_space, 
        is_last_folder, 
        is_last_list, 
        result_lines, 
        colorize_output, 
        show_full, 
        include_completed, 
        hide_orphaned, 
        show_score, 
        show_tags, 
        tag_style, 
        show_type_emoji, 
        top_level_orphaned_tasks
    )

def _format_orphaned_list_tasks(
    tasks_in_list: List[Dict[str, Any]],
    tasks_map: Dict[str, Dict],
    displayed_task_ids: Set[str],
    orphaned_task_ids: Set[str],
    is_last_space: bool,
    is_last_folder: bool,
    is_last_list: bool,
    result_lines: List[str],
    colorize_output: bool = True,
    show_full: bool = False,
    include_completed: bool = False,
    hide_orphaned: bool = False,
    show_score: bool = False,
    show_tags: bool = False,
    tag_style: str = "colored",
    show_type_emoji: bool = True,
    top_level_orphaned_tasks: List[Dict[str, Any]] = None
) -> None:
    """
    Format orphaned tasks within a list container.
    
    Task: tsk_1e88842d - Tree Structure Validation
    dohcount: 1
    
    Args:
        tasks_in_list: Tasks in the current list
        tasks_map: Map of task IDs to tasks
        displayed_task_ids: Set of task IDs that have already been displayed
        orphaned_task_ids: Set of task IDs that are orphaned
        is_last_space: Whether this is in the last space
        is_last_folder: Whether this is in the last folder
        is_last_list: Whether this is the last list
        result_lines: List of strings to append formatted output to
        colorize_output: Whether to colorize the output
        show_full: Whether to show full task details
        include_completed: Whether to include completed tasks
        hide_orphaned: Whether to hide orphaned tasks
        show_score: Whether to show scores
        show_tags: Whether to show tags
        tag_style: Style for tags
        show_type_emoji: Whether to show task type emoji
        top_level_orphaned_tasks: List of top-level orphaned tasks
    """
    if top_level_orphaned_tasks is None:
        top_level_orphaned_tasks = []

    # Check for orphaned tasks (not in hierarchy but in this list)
    # We're skipping adding the orphaned tasks section if hide_orphaned is True
    if not hide_orphaned:
        orphaned_tasks = [
            task for task in tasks_in_list 
            if task.get('id') not in displayed_task_ids
        ]
        
        # Add orphaned tasks section if needed
        if orphaned_tasks:
            # Create task prefix that accounts for all parent containers
            orphan_prefix = ""
            if is_last_space and not top_level_orphaned_tasks:
                orphan_prefix += "  "  # Space is last, no pipe
            else:
                orphan_prefix += "â”‚ "  # Space continues, need pipe
                
            if is_last_folder:
                orphan_prefix += "  "  # Folder is last, no pipe
            else:
                orphan_prefix += "â”‚ "  # Folder continues, need pipe
                
            if is_last_list:
                orphan_prefix += "  "  # List is last, no pipe
            else:
                orphan_prefix += "â”‚ "  # List continues, need pipe
            
            # Add orphaned tasks header with proper branch character
            if colorize_output:
                from refactor.utils.colors import TextColor
                result_lines.append(f"{orphan_prefix}â””â”€{colorize('Orphaned Tasks:', TextColor.BRIGHT_RED)}")
            else:
                result_lines.append(f"{orphan_prefix}â””â”€Orphaned Tasks:")
            
            # Sort orphaned tasks
            sorted_orphans = sorted(
                orphaned_tasks,
                key=lambda t: (
                    t.get('status', '').lower() == 'complete',
                    int(t.get('priority', 4)),
                    t.get('name', '')
                )
            )
            
            # Create orphaned tasks prefix (one level deeper)
            orphan_items_prefix = orphan_prefix + "  "  # Orphaned header is last, no pipe
            
            # Format each orphaned task
            for orphan_idx, orphan in enumerate(sorted_orphans):
                is_last_orphan = orphan_idx == len(sorted_orphans) - 1
                
                # Format basic task info
                task_description = _format_task_basic_info(orphan, colorize_output, show_full, show_score, show_tags, tag_style, show_type_emoji)
                branch = "â””â”€" if is_last_orphan else "â”œâ”€"
                result_lines.append(f"{orphan_items_prefix}{branch}{task_description}")
                
                # Mark as displayed
                displayed_task_ids.add(orphan.get('id'))
                
                # Format subtask hierarchy
                subtask_lines = []
                
                # Recursively display all subtasks of the orphaned task
                _format_subtask_hierarchy(
                    orphan,
                    tasks_map,
                    subtask_lines,
                    displayed_task_ids,
                    orphan_items_prefix + ("  " if is_last_orphan else "â”‚ "),
                    colorize_output,
                    show_full,
                    include_completed,
                    hide_orphaned,
                    orphaned_task_ids,
                    show_score,
                    show_tags,
                    tag_style,
                    show_type_emoji
                )
                
                # Add subtask lines to result
                for line in subtask_lines:
                    result_lines.append(line)

def _format_hierarchical_task(
    task: Dict[str, Any],
    tasks_map: Dict[str, Dict],
    level: int = 0,
    indent: int = 2,
    colorize_output: bool = False,
    show_relationships: bool = False,
    core_manager = None,
    show_content_preview: bool = False,
    content_preview_length: int = 80,
    show_comments: int = 0,
    is_last_at_level: bool = False,
    displayed_tasks: Set[str] = None,
    branch_map: Dict[int, bool] = None,
    include_completed: bool = False,
    show_score: bool = False,
    show_tags: bool = False,
    tag_style: str = "colored",
    show_type_emoji: bool = True
) -> List[str]:
    """
    Format a task and its subtasks in a hierarchical structure.
    
    Task: tsk_fa92b435 - Tree Structure Validation
    dohcount: 1
    
    Args:
        task: Task dictionary to format
        tasks_map: Dictionary mapping task IDs to tasks
        level: Current indentation level
        indent: Number of spaces per indentation level
        colorize_output: Whether to use ANSI colors
        show_relationships: Whether to show task relationships
        core_manager: Core manager instance for additional data
        show_content_preview: Whether to show content preview
        content_preview_length: Maximum length of content preview
        show_comments: Number of comments to show (0 for none)
        is_last_at_level: Whether this task is the last at its level
        displayed_tasks: Set of already displayed task IDs
        branch_map: Dictionary tracking which levels need vertical pipes
        include_completed: Whether to include completed tasks
        show_score: Whether to show task scores
        show_tags: Whether to show tags
        tag_style: Style for tag display
        show_type_emoji: Whether to show task type emoji
    
    Returns:
        List of formatted lines
    """
    if displayed_tasks is None:
        displayed_tasks = set()
        
    if branch_map is None:
        branch_map = {}
        
    # Check if task has already been displayed
    task_id = task.get('id')
    if task_id in displayed_tasks:
        return []
        
    # Mark task as displayed
    if task_id:
        displayed_tasks.add(task_id)
        
    # Skip completed tasks unless include_completed is True
    if task.get('status') == 'complete' and not include_completed:
        return []
        
    lines = []
    
    # Create prefix based on level and branch map
    prefix = ""
    for i in range(level):
        if i in branch_map and branch_map[i]:
            prefix += "â”‚ "
        else:
            prefix += "  "
            
    # Add connector based on whether this is the last item
    connector = "â””â”€" if is_last_at_level else "â”œâ”€"
    
    # Format basic task info
    task_info = _format_task_basic_info(
        task,
        colorize_output=colorize_output,
        show_full=show_full,
        show_score=show_score,
        show_tags=False,  # We'll handle tags separately
        tag_style=tag_style,
        show_type_emoji=show_type_emoji
    )
    
    # Add the task line
    lines.append(f"{prefix}{connector}{task_info}")
    
    # Add tags on their own line if available and requested
    if show_tags and task.get('tags'):
        tags = task.get('tags', [])
        # Format tags in brackets separated by commas
        tags_text = f"{', '.join(tags)}"
        
        # Determine indentation for tag line based on branch map
        tag_prefix = prefix + ("  " if is_last_at_level else "â”‚ ")
        
        # Add tag emoji and brackets
        tag_line = f"{tag_prefix}{TAG_EMOJI} [{tags_text}]"
        lines.append(tag_line)
        
    # If showing relationships, add them
    if show_relationships and core_manager:
        # TODO: Format relationships
        pass
        
    # If showing content preview, add it
    if show_content_preview and task.get('description'):
        # TODO: Format content preview
        pass
        
    # If showing comments, add them
    if show_comments > 0 and task.get('comments'):
        # TODO: Format comments
        pass
        
    # Get subtasks for this task
    subtasks = _get_subtasks(task, tasks_map, include_completed)
    
    # Sort subtasks by priority
    subtasks.sort(key=lambda t: (
        t.get('status') == 'complete',  # Completed tasks at end
        int(t.get('priority', 3))       # Higher priority (lower number) first
    ))
    
    # Format each subtask
    for i, subtask in enumerate(subtasks):
        is_last_subtask = i == len(subtasks) - 1
        
        # Update branch map for subtask
        new_branch_map = branch_map.copy()
        new_branch_map[level] = not is_last_at_level
        
        # Format the subtask
        subtask_lines = _format_hierarchical_task(
            subtask,
            tasks_map,
            level=level + 1,
            indent=indent,
            colorize_output=colorize_output,
            show_relationships=show_relationships,
            core_manager=core_manager,
            show_content_preview=show_content_preview,
            content_preview_length=content_preview_length,
            show_comments=show_comments,
            is_last_at_level=is_last_subtask,
            displayed_tasks=displayed_tasks,
            branch_map=new_branch_map,
            include_completed=include_completed,
            show_score=show_score,
            show_tags=show_tags,
            tag_style=tag_style,
            show_type_emoji=show_type_emoji
        )
        
        lines.extend(subtask_lines)
        
    return lines

def _get_subtasks(task: Dict[str, Any], tasks_map: Dict[str, Dict], include_completed: bool = False) -> List[Dict]:
    """
    Get all direct subtasks of a task.
    
    Args:
        task: The parent task
        tasks_map: Map of all tasks by ID
        include_completed: Whether to include completed subtasks
        
    Returns:
        List of subtask dictionaries
    """
    task_id = task.get('id')
    subtasks = []
    
    for potential_subtask in tasks_map.values():
        if potential_subtask.get('parent_id') == task_id:
            if include_completed or potential_subtask.get('status', '').lower() != 'complete':
                subtasks.append(potential_subtask)
                
    # Sort subtasks by status, priority, and name
    return sorted(
        subtasks,
        key=lambda t: (
            t.get('status', '').lower() == 'complete',  # Incomplete first
            int(t.get('priority', 4)),                 # Lower priority value (higher importance) first
            t.get('name', '')                          # Alphabetical by name
        )
    )

def format_task_list(
    tasks: List[Dict[str, Any]], 
    show_ids: bool = True, 
    truncate: bool = True, 
    truncate_length: int = 50, 
    colorize: bool = True,
    show_tags: bool = True,
    tag_style: str = "colored",
    show_type_emoji: bool = True
) -> str:
    """
    Format a list of tasks as a simple list (not hierarchical).
    
    Task: tsk_22a152df - Show Tags Option
    dohcount: 4
    
    Purpose:
        Creates a formatted string representation of a list of tasks.
    
    Parameters:
        tasks: List of task dictionaries
        show_ids: Whether to show task IDs
        truncate: Whether to truncate long task names
        truncate_length: Maximum length for truncated task names
        colorize: Whether to use ANSI colors in output
        show_tags: Whether to show task tags
        tag_style: Style for tag display ('brackets', 'hash', 'colored')
        show_type_emoji: Whether to show task type emoji
    
    Returns:
        Formatted string with task list
    """
    if not tasks:
        return "No tasks found."
    
    result = []
    
    # Sort tasks by priority
    sorted_tasks = sorted(tasks, key=lambda t: int(t.get('priority', 4)))
    
    for task in sorted_tasks:
        task_id = task.get('id', 'unknown')
        task_name = task.get('name', 'Unnamed Task')
        task_status = task.get('status', '').lower()
        task_priority = task.get('priority', 4)
        task_tags = task.get('tags', [])
        task_type = task.get('task_type', 'task').lower()
        
        # Truncate task name if requested
        if truncate and len(task_name) > truncate_length:
            task_name = task_name[:truncate_length-3] + "..."
        
        # Format with colors if enabled
        if colorize:
            from refactor.utils.colors import colorize, task_status_color, priority_color, TextColor
            from refactor.core.entities.task_type import task_type_color
            
            # Format status and priority with colors
            if task_status:
                status_text = colorize(f"[{task_status}]", task_status_color(task_status))
            else:
                status_text = ""
                
            priority_text = colorize(f"(P{task_priority})", priority_color(task_priority))
            
            # Add emoji based on task type
            emoji = ""
            if show_type_emoji:
                emoji = TASK_TYPE_EMOJI_MAP.get(task_type, "ðŸ“‹") + " "
            
            # Colorize task name based on task type
            colored_task_name = colorize(task_name, task_type_color(task_type))
            
            # Build the main task line
            if show_ids:
                id_text = colorize(f" [{task_id}]", TextColor.BRIGHT_BLACK)
                task_line = f"{emoji}{colored_task_name} {status_text} {priority_text}{id_text}"
            else:
                task_line = f"{emoji}{colored_task_name} {status_text} {priority_text}"
            
            # Format tags if requested
            if show_tags and task_tags:
                # Add tags on a new line with proper indentation and tag emoji
                tags_text = "    â”‚ " + TAG_EMOJI + " " + format_tags(task_tags, colorize, tag_style)
                task_line = f"{task_line}\n{tags_text}"
        else:
            # Plain text formatting without colors
            if task_status:
                status_text = f"[{task_status}]"
            else:
                status_text = ""
                
            priority_text = f"(P{task_priority})"
            
            # Add emoji based on task type
            emoji = ""
            if show_type_emoji:
                emoji = TASK_TYPE_EMOJI_MAP.get(task_type, "ðŸ“‹") + " "
            
            # Build the main task line
            if show_ids:
                task_line = f"{emoji}{task_name} {status_text} {priority_text} [{task_id}]"
            else:
                task_line = f"{emoji}{task_name} {status_text} {priority_text}"
            
            # Format tags if requested
            if show_tags and task_tags:
                # Add tags on a new line with proper indentation and tag emoji
                tags_text = "    â”‚ " + TAG_EMOJI + " " + format_tags(task_tags, False, tag_style)
                task_line = f"{task_line}\n{tags_text}"
        
        result.append(task_line)
    
    return "\n".join(result)

def format_tags(tags: List[str], colorize: bool = False, style: str = "colored") -> str:
    """
    Format task tags with the specified style.
    
    Task: tsk_22a152df - Show Tags Option
    dohcount: 3
    
    Related Tasks:
        - tsk_3b14d960 - List Command Argument Investigation (parent)
        - tsk_fa92b435 - Tree Structure Validation (related)
    
    Used By:
        - _format_task_basic_info: For displaying tags in task listings
        - format_task_hierarchy: For displaying tags in hierarchical views
    
    Purpose:
        Format a list of tags with different style options for display in task listings.
    
    Requirements:
        - Must support different styling options (brackets, hash prefix, colors)
        - Must handle empty tag lists gracefully
        - Must use colorization only when explicitly enabled
        - CRITICAL: Must format tags in brackets without hash symbols for tree displays
    
    Parameters:
        tags (List[str]): List of tag strings to format
        colorize (bool): Whether to use color in the output
        style (str): Style to use ('brackets', 'hash', or 'colored')
    
    Returns:
        str: Formatted tag string
        
    Examples:
        >>> format_tags(["bug", "critical"], False, "brackets")
        "[bug] [critical]"
        >>> format_tags(["feature", "ui"], False, "hash")
        "#feature #ui"
        >>> format_tags(["performance", "optimization"], False, "tree")
        "performance, optimization"
    """
    if not tags:
        return ""
    
    # For tree view, just return comma-separated tags without hash symbols
    if style == "tree":
        return ", ".join(tags)
    
    if style == "brackets":
        return " ".join(f"[{tag}]" for tag in tags)
    elif style == "hash":
        return " ".join(f"#{tag}" for tag in tags)
    elif style == "colored" and colorize:
        # Import here to avoid circular imports
        from refactor.utils.colors import TextColor, colorize as color_text
        return " ".join(color_text(f"#{tag}", TextColor.BRIGHT_CYAN) for tag in tags)
    else:
        # Default to hash style if colored is requested but colors are disabled
        return " ".join(f"#{tag}" for tag in tags)

def _format_task_basic_info(
    task: Dict[str, Any], 
    colorize_output: bool = False, 
    show_full: bool = False,
    show_score: bool = False,
    show_tags: bool = True,
    tag_style: str = "colored",
    show_type_emoji: bool = True
) -> str:
    """
    Format basic task information for display.
    
    Task: tsk_22a152df - Show Tags Option
    dohcount: 5
    
    Related Tasks:
        - tsk_3b14d960 - List Command Argument Investigation (parent)
        - tsk_da3dfe13 - Descriptive Task Display (related)
        - tsk_fa92b435 - Tree Structure Validation (related)
    
    Purpose:
        Format a task's basic information for display in listings and hierarchies.
    
    Requirements:
        - Must handle tags as properly indented children in tree displays
        - Must maintain vertical pipe alignment in hierarchical displays
        - Must use consistent indentation for child elements
    
    Parameters:
        task: Task dictionary containing task data
        colorize_output: Whether to use ANSI colors in output
        show_full: Whether to show full details
        show_score: Whether to show scores
        show_tags: Whether to show tags
        tag_style: Style for tag display
        show_type_emoji: Whether to show task type emoji
    
    Returns:
        str: Formatted task information (may include multiple lines)
    """
    from refactor.utils.colors import colorize, task_status_color, priority_color, TextColor
    from refactor.core.entities.task_type import task_type_color
    
    # Extract basic task information
    task_id = task.get('id', '')
    task_name = task.get('name', 'Unnamed Task')
    task_status = task.get('status', '')
    task_priority = task.get('priority', 4)
    task_tags = task.get('tags', [])
    task_due_date = task.get('due_date', '')
    task_type = task.get('task_type', 'task').lower()
    
    # Format task type emoji if requested
    emoji = ""
    if show_type_emoji:
        emoji = TASK_TYPE_EMOJI_MAP.get(task_type, "ðŸ“‹") + " "
    
    # Basic formatted string
    if colorize_output:
        status_text = colorize(f"[{task_status}]", task_status_color(task_status)) if task_status else ""
        priority_text = colorize(f"(P{task_priority})", priority_color(task_priority))
        colored_name = colorize(task_name, task_type_color(task_type))
        id_text = colorize(f"[{task_id}]", TextColor.BRIGHT_BLACK) if task_id else ""
        
        # Basic task information line
        formatted = f"{emoji}{colored_name} {status_text} {priority_text} {id_text}".strip()
    else:
        status_text = f"[{task_status}]" if task_status else ""
        priority_text = f"(P{task_priority})"
        
        # Basic task information line
        formatted = f"{emoji}{task_name} {status_text} {priority_text}"
        if task_id:
            formatted += f" [{task_id}]"
    
    # Add scores if requested
    if show_score and 'scores' in task and task['scores']:
        scores = task['scores']
        
        # Import scoring functions
        from refactor.utils.colors import (
            total_score_color, effort_score_color, 
            effectiveness_score_color, risk_score_color,
            urgency_score_color, colorize
        )
        
        # Format each score
        total = scores.get('total', 0)
        effort = scores.get('effort', 0)
        effectiveness = scores.get('effectiveness', 0)
        risk = scores.get('risk', 0)
        urgency = scores.get('urgency', 0)
        
        if colorize_output:
            score_text = (
                colorize(f"T:{total:.1f}", total_score_color(total)) + " " +
                colorize(f"EF:{effort:.1f}", effort_score_color(effort)) + " " +
                colorize(f"EV:{effectiveness:.1f}", effectiveness_score_color(effectiveness)) + " " +
                colorize(f"R:{risk:.1f}", risk_score_color(risk)) + " " +
                colorize(f"U:{urgency:.1f}", urgency_score_color(urgency))
            )
        else:
            score_text = f"T:{total:.1f} EF:{effort:.1f} EV:{effectiveness:.1f} R:{risk:.1f} U:{urgency:.1f}"
        
        formatted += f" {score_text}"
    
    # Note: Tags are now handled in the hierarchical display functions
    # to ensure proper tree structure. We don't add them here to avoid
    # breaking the tree formatting.
    
    # Extend with full details if requested
    if show_full:
        if task_due_date:
            formatted += f"\n  Due: {task_due_date}"
            
        if 'description' in task and task['description']:
            # Truncate description if too long
            desc = task['description']
            if len(desc) > 100:
                desc = desc[:97] + "..."
            formatted += f"\n  Desc: {desc}"
            
        if 'comments' in task and task['comments']:
            comment_count = len(task['comments'])
            formatted += f"\n  Comments: {comment_count}"
            
    return formatted.strip()

def _format_subtask_hierarchy(
    parent_task: Dict[str, Any],
    tasks_map: Dict[str, Dict],
    lines: List[str],
    displayed_task_ids: Set[str],
    current_prefix: str,
    colorize_output: bool = True,
    show_full: bool = False,
    include_completed: bool = False,
    hide_orphaned: bool = False,
    orphaned_task_ids: Set[str] = None,
    show_score: bool = False,
    show_tags: bool = False,
    tag_style: str = "colored",
    show_type_emoji: bool = True
) -> None:
    """
    Recursively format and display subtasks in a hierarchical tree.
    
    Task: tsk_309ea4c2 - Improve Container Hierarchy Display
    dohcount: 1
    
    Related Tasks:
        - tsk_ef072a47 - Display Features (parent)
        - stk_b4c3d9a2 - Fix Orphaned Task Detection (subtask)
    
    Used By:
        - _format_container_hierarchy: To display subtasks hierarchically under their parent tasks
    
    Purpose:
        Recursively formats and displays all levels of subtasks under a parent task.
    
    Requirements:
        - Must maintain proper branch characters at each level
        - Must keep track of displayed tasks to avoid duplicates
        - Must handle orphaned tasks correctly
        - CRITICAL: Must recursively process all levels of subtasks
    
    Parameters:
        parent_task: The parent task dictionary
        tasks_map: Map of all tasks by ID
        lines: List of output lines to append to
        displayed_task_ids: Set of task IDs that have already been displayed
        current_prefix: The prefix string for the current level
        colorize_output: Whether to use ANSI colors
        show_full: Whether to show full task details
        include_completed: Whether to include completed tasks
        hide_orphaned: Whether to hide orphaned tasks
        orphaned_task_ids: Set of orphaned task IDs to exclude
        show_score: Whether to show task scores
        show_tags: Whether to show task tags
        tag_style: Style for tag display
        show_type_emoji: Whether to show task type emoji
    """
    # Get subtasks
    parent_id = parent_task.get('id')
    subtasks = []
    
    for task_id, task in tasks_map.items():
        if task.get('parent_id') == parent_id:
            # Skip completed tasks if include_completed is False
            if not include_completed and task.get('status', '').lower() == 'complete':
                continue
                
            # Skip orphaned tasks if hide_orphaned is True
            if hide_orphaned and task_id in orphaned_task_ids:
                continue
                
            subtasks.append(task)
    
    # Sort subtasks
    sorted_subtasks = sorted(
        subtasks,
        key=lambda t: (
            t.get('status', '').lower() == 'complete',  # Incomplete first
            int(t.get('priority', 4)),                  # Lower priority first
            t.get('name', '')                           # Alphabetical
        )
    )
    
    # Process each subtask
    for idx, subtask in enumerate(sorted_subtasks):
        # Skip if already displayed
        if subtask.get('id') in displayed_task_ids:
            continue
            
        is_last = idx == len(sorted_subtasks) - 1
        branch = "â””â”€" if is_last else "â”œâ”€"
        
        # Format and display subtask
        task_description = _format_task_basic_info(subtask, colorize_output, show_full, show_score, show_tags, tag_style, show_type_emoji)
        lines.append(f"{current_prefix}{branch}{task_description}")
        
        # Mark as displayed
        displayed_task_ids.add(subtask.get('id'))
        
        # Recursively process its subtasks
        next_prefix = current_prefix + ("  " if is_last else "â”‚ ")
        _format_subtask_hierarchy(
            subtask,
            tasks_map,
            lines,
            displayed_task_ids,
            next_prefix,
            colorize_output,
            show_full,
            include_completed,
            hide_orphaned,
            orphaned_task_ids,
            show_score,
            show_tags,
            tag_style,
            show_type_emoji
        )

def _format_task_scores(task: Dict[str, Any], colorize_output: bool = False) -> str:
    """
    Format task scores for display.
    
    Task: tsk_22a152df - Show Tags Option
    dohcount: 1
    
    Used By:
        - _format_task_basic_info: For displaying scores in task listings
    
    Purpose:
        Format a task's score information for display.
    
    Parameters:
        task: Task dictionary containing score data
        colorize_output: Whether to use ANSI colors in output
    
    Returns:
        String with formatted score details
    """
    if 'scores' not in task:
        return ""
    
    scores = task.get('scores', {})
    total_score = scores.get('total', 0)
    effort_score = scores.get('effort', 0)
    effectiveness_score = scores.get('effectiveness', 0)
    risk_score = scores.get('risk', 0)
    urgency_score = scores.get('urgency', 0)
    
    score_indicators = ""
    
    if colorize_output:
        from refactor.utils.colors import (
            colorize, total_score_color, effort_score_color, 
            effectiveness_score_color, risk_score_color, urgency_score_color
        )
        
        # Format scores with distinct colors for each type
        if total_score:
            total_score_text = f'(T:{total_score})'
            score_indicators += f" {colorize(total_score_text, total_score_color(total_score))}"
        
        if effort_score:
            effort_score_text = f'(EF:{effort_score})'
            score_indicators += f" {colorize(effort_score_text, effort_score_color(effort_score))}"
            
        if effectiveness_score:
            effectiveness_score_text = f'(EV:{effectiveness_score})'
            score_indicators += f" {colorize(effectiveness_score_text, effectiveness_score_color(effectiveness_score))}"
            
        if risk_score:
            risk_score_text = f'(R:{risk_score})'
            score_indicators += f" {colorize(risk_score_text, risk_score_color(risk_score))}"
            
        if urgency_score:
            urgency_score_text = f'(U:{urgency_score})'
            score_indicators += f" {colorize(urgency_score_text, urgency_score_color(urgency_score))}"
    else:
        # Non-colored version
        if total_score:
            score_indicators += f" (T:{total_score})"
        
        if effort_score:
            score_indicators += f" (EF:{effort_score})"
            
        if effectiveness_score:
            score_indicators += f" (EV:{effectiveness_score})"
            
        if risk_score:
            score_indicators += f" (R:{risk_score})"
            
        if urgency_score:
            score_indicators += f" (U:{urgency_score})"
    
    return score_indicators.strip()

def fix_tree_structure(tree_lines: List[str]) -> List[str]:
    """
    Auto-corrects common tree structure issues to ensure proper vertical pipe alignment.
    
    Task: tsk_fa92b435 - Tree Structure Validation
    dohcount: 2
    
    Parameters:
        tree_lines: List of rendered tree lines
    
    Returns:
        List of corrected tree lines
    """
    if not tree_lines:
        return tree_lines
    
    # Fix nested strings issue - if tree_lines contains nested lists or strings
    flat_lines = []
    for line in tree_lines:
        if isinstance(line, str):
            flat_lines.append(line)
        elif isinstance(line, list):
            # Handle case where strings are nested in lists
            for nested_line in line:
                if isinstance(nested_line, str):
                    flat_lines.append(nested_line)
    
    if not flat_lines:
        return tree_lines  # Return original if nothing to fix
        
    fixed_lines = flat_lines.copy()
    pipe_positions = {}
    
    # First pass: Find pipe positions at each level
    for i, line in enumerate(fixed_lines):
        if not line.strip():
            continue
            
        # Count leading spaces to determine level
        leading_spaces = len(line) - len(line.lstrip())
        level = leading_spaces // 2  # Assuming 2-space indentation
        
        # Find pipe characters
        for j, char in enumerate(line):
            if char == 'â”‚':
                if level not in pipe_positions:
                    pipe_positions[level] = set()
                pipe_positions[level].add(j)
            elif char in ('â”œ', 'â””') and j % 2 == 0:  # Only consider properly aligned branch chars
                if level not in pipe_positions:
                    pipe_positions[level] = set()
                pipe_positions[level].add(j)
    
    # Second pass: Fix pipe positions
    for i, line in enumerate(fixed_lines):
        if not line.strip():
            continue
            
        # Skip tag lines from automatic correction
        is_tag_line = TAG_EMOJI in line and line.strip().startswith(TAG_EMOJI)
        
        # Create a list from the line to allow character replacements
        line_chars = list(line)
        
        # Count leading spaces to determine level
        leading_spaces = len(line) - len(line.lstrip())
        line_level = leading_spaces // 2  # Assuming 2-space indentation
        
        # For each level
        for level, positions in sorted(pipe_positions.items()):
            # Only fix pipes for levels below this line's level
            if level >= line_level:
                continue
                
            for pos in sorted(positions):
                # Skip positions beyond this line
                if pos >= len(line_chars):
                    continue
                
                # Only replace space with pipe if it meets the criteria
                if (line_chars[pos] == ' ' and 
                    pos % 2 == 0 and  # Only fix at even positions (0, 2, 4...)
                    # Don't add pipes to tag lines at parent pipe positions
                    not is_tag_line):
                    
                    # Check surrounding context
                    if (pos > 0 and pos < len(line_chars) - 1 and 
                        line_chars[pos-1] == ' ' and 
                        (line_chars[pos+1] == ' ' or line_chars[pos+1] in ('â”œ', 'â””'))):
                        line_chars[pos] = 'â”‚'
        
        # Reconstruct the fixed line
        fixed_lines[i] = ''.join(line_chars)
    
    # Third pass: Fix branch characters
    for i, line in enumerate(fixed_lines):
        if not line.strip():
            continue
            
        # Fix branch characters
        fixed_lines[i] = (line.replace('|-', 'â”œâ”€')
                          .replace('\\-', 'â””â”€')
                          .replace('+--', 'â”œâ”€')
                          .replace('`--', 'â””â”€')
                          .replace('|--', 'â”œâ”€'))
    
    return fixed_lines

# Make sure to restore other functions from the file, fixing indentation issues in each